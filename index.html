<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no"/>
<title>Wallpaper Shapes — Mobile Stealth</title>
<style>
  html,body { height:100%; margin:0; background:#000; -webkit-tap-highlight-color: rgba(0,0,0,0); }
  canvas { display:block; width:100vw; height:100vh; }
  #ui {
    position: absolute; left:12px; top:12px;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    color: #fff; z-index: 10;
    user-select: none; -webkit-user-select:none;
  }
  #healthBox{
    width:220px; height:22px; background: rgba(255,255,255,0.06);
    border-radius:6px; padding:2px; box-sizing:border-box; border:1px solid rgba(255,255,255,0.08);
    display:flex; align-items:center;
  }
  #healthBar{
    height:100%; width:100%; background: linear-gradient(90deg,#10b981,#84cc16); border-radius:4px;
    box-shadow: 0 4px 18px rgba(0,0,0,0.5) inset;
  }
  #status { margin-top:8px; font-weight:600; font-size:14px; text-shadow:0 1px 0 rgba(0,0,0,0.6); }
  #hint { position: absolute; bottom:12px; left:0; right:0; text-align:center; color:rgba(255,255,255,0.85); font-size:14px; pointer-events:none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div id="healthBox"><div id="healthBar"></div></div>
  <div id="status">Tap to move • Two-finger tap to morph</div>
</div>
<div id="hint">Wallpaper made of sacred geometry • Enemies are pulsing blobs</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  function resize(){ canvas.width = innerWidth * devicePixelRatio; canvas.height = innerHeight * devicePixelRatio; canvas.style.width = innerWidth + 'px'; canvas.style.height = innerHeight + 'px'; ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0); }
  addEventListener('resize', resize);
  resize();

  // World
  let world = { x: 0, y: 0 };         // wallpaper offset (continuous)
  let depth = 0;                      // controls pattern blending
  let t = 0;

  // Player
  const player = {
    x: innerWidth / 2,
    y: innerHeight / 2,
    r: 36,
    color: { h: 200, s: 85, l: 55 },
    shapeIndex: 0,
    shapes: ['flower','star','roundedHex','ringStack','spiralBlob'],
    vx: 0, vy: 0,
    target: null,
    health: 100,
    flash: 0, // red tint timer
    inv: 0   // invincibility frames
  };

  // Enemies: persistent pulsing blobs
  const ENEMY_COUNT = 8;
  const enemies = [];
  for (let i=0;i<ENEMY_COUNT;i++){
    enemies.push({
      x: Math.random() * innerWidth,
      y: Math.random() * innerHeight,
      baseR: 18 + Math.random()*22,
      pulseSeed: Math.random()*Math.PI*2,
      wobbleSeed: Math.random()*1000,
      speed: 0.4 + Math.random()*0.9,
      hue: 340 + Math.random()*40,
      vx: (Math.random()-0.5)*0.5,
      vy: (Math.random()-0.5)*0.5
    });
  }

  const healthBarEl = document.getElementById('healthBar');

  // helper: HSL string
  function hsl(h,s,l,a=1){ return `hsla(${h} ${s}% ${l}% / ${a})`; }

  // wallpaper patterns: provide a set of draw functions; blend weight depends on world position
  function drawFlowerOfLife(offX, offY, scale=1, alpha=1){
    // overlapping circles (flower of life)
    const spacing = 48 * scale;
    ctx.strokeStyle = `hsla(190 90% 75% / ${alpha * 0.95})`;
    ctx.lineWidth = 1.6;
    for (let gx = -2; gx <= Math.ceil(innerWidth/spacing)+2; gx++){
      for (let gy = -2; gy <= Math.ceil(innerHeight/spacing)+2; gy++){
        const cx = Math.round((gx * spacing + offX % spacing));
        const cy = Math.round((gy * spacing + offY % spacing));
        ctx.beginPath();
        ctx.arc(cx, cy, spacing * 0.45, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  function drawHexGrid(offX, offY, scale=1, alpha=1){
    const size = 36 * scale;
    ctx.strokeStyle = `hsla(230 80% 80% / ${alpha})`;
    ctx.lineWidth = 1.4;
    const h = Math.sqrt(3) * size;
    for (let y = -h; y < innerHeight + h; y += h){
      for (let x = -size*2; x < innerWidth + size*2; x += size*1.5){
        const ox = x + ((Math.floor((y + offY)/h) % 2) ? size * 0.75 : 0) + (offX % (size*1.5));
        const oy = y + (offY % h);
        // hexagon
        ctx.beginPath();
        for (let i=0;i<6;i++){
          const ang = Math.PI/3 * i - Math.PI/6;
          const px = ox + Math.cos(ang) * size;
          const py = oy + Math.sin(ang) * size;
          if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.closePath();
        ctx.stroke();
      }
    }
  }

  function drawStarPolygons(offX, offY, scale=1, alpha=1){
    ctx.strokeStyle = `hsla(260 90% 80% / ${alpha})`;
    ctx.lineWidth = 1.2;
    const step = 160 * scale;
    for (let x=-step; x<innerWidth+step; x+=step){
      for (let y=-step; y<innerHeight+step; y+=step){
        const cx = x + (offX % step), cy = y + (offY % step);
        // 8-point star
        ctx.beginPath();
        for (let i=0;i<16;i++){
          const ang = (Math.PI*2/16)*i;
          const rad = i%2===0 ? 48*scale : 18*scale;
          const px = cx + Math.cos(ang)*rad;
          const py = cy + Math.sin(ang)*rad;
          if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.closePath();
        ctx.stroke();
      }
    }
  }

  function drawRingStack(offX, offY, scale=1, alpha=1){
    ctx.strokeStyle = `hsla(20 90% 85% / ${alpha})`;
    ctx.lineWidth = 1.7;
    const spacing = 120*scale;
    for (let x=-spacing; x<innerWidth+spacing; x+=spacing){
      for (let y=-spacing; y<innerHeight+spacing; y+=spacing){
        const cx = x + (offX % spacing), cy = y + (offY % spacing);
        for (let s=0; s<4; s++){
          ctx.beginPath();
          ctx.arc(cx, cy, 18 + s*16, 0, Math.PI*2);
          ctx.stroke();
        }
      }
    }
  }

  function drawSpiralGrids(offX, offY, scale=1, alpha=1){
    ctx.strokeStyle = `hsla(120 85% 75% / ${alpha})`;
    ctx.lineWidth = 1.2;
    const spacing = 90 * scale;
    for (let x=-spacing; x<innerWidth+spacing; x+=spacing){
      for (let y=-spacing; y<innerHeight+spacing; y+=spacing){
        const cx = x + (offX % spacing), cy = y + (offY % spacing);
        ctx.beginPath();
        for (let a=0; a<Math.PI*2; a+=0.12){
          const rr = 6 + a*6;
          const px = cx + Math.cos(a) * rr;
          const py = cy + Math.sin(a) * rr;
          if (a===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.stroke();
      }
    }
  }

  const patternDrawers = [drawFlowerOfLife, drawHexGrid, drawStarPolygons, drawRingStack, drawSpiralGrids];

  // draw wallpaper: blend patterns based on world position
  function drawWallpaper(){
    // sample continuous coordinates produce blend weights (use sin/cos of world coords)
    const wx = world.x * 0.003;
    const wy = world.y * 0.003;
    const wNoise = [];
    for (let i=0;i<patternDrawers.length;i++){
      // produce smooth weights from sines, so neighboring areas vary
      const angle = (wx* (i+1) + wy * (i+2)) + t*0.02*(i+1);
      const w = 0.6 + 0.5 * Math.sin(angle + i);
      wNoise.push(Math.max(0, w));
    }
    // normalize
    const sum = wNoise.reduce((a,b)=>a+b,0);
    for (let i=0;i<patternDrawers.length;i++){
      const weight = (wNoise[i]/sum) ** 1.2; // bias
      if (weight < 0.01) continue;
      ctx.save();
      ctx.globalCompositeOperation = 'lighter';
      patternDrawers[i](world.x, world.y, 1 + depth*0.02, weight*1.0);
      ctx.restore();
    }
    // subtle vignette for contrast
    const g = ctx.createLinearGradient(0,0,0,innerHeight);
    g.addColorStop(0, 'rgba(0,0,0,0.0)');
    g.addColorStop(1, 'rgba(0,0,0,0.12)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,innerWidth, innerHeight);
  }

  // Complex player shapes
  function drawPlayerShape(px, py, r, shapeName, color, flash=0){
    ctx.save();
    ctx.translate(px,py);
    // outer glow + stroke so it stands out
    ctx.shadowColor = 'rgba(0,0,0,0.6)';
    ctx.shadowBlur = 18;
    ctx.globalCompositeOperation = 'source-over';
    // fill color
    const base = `hsl(${color.h} ${color.s}% ${color.l}%)`;
    const fillCol = flash > 0 ? `hsl(0 90% 60% / ${0.95})` : base;
    ctx.fillStyle = fillCol;
    ctx.strokeStyle = `rgba(0,0,0,0.6)`;
    ctx.lineWidth = 2.6;

    if (shapeName === 'flower'){
      // small layered petal form
      for (let k=0;k<3;k++){
        ctx.beginPath();
        const scale = 1 - k*0.18;
        for (let i=0;i<8;i++){
          const a = i/8 * Math.PI*2 + k*0.12;
          const rx = Math.cos(a) * r * 0.9 * scale + Math.sin(t*0.003 + k)*6;
          const ry = Math.sin(a) * r * 0.9 * scale + Math.cos(t*0.002 + k)*6;
          if (i===0) ctx.moveTo(rx,ry); else ctx.lineTo(rx,ry);
        }
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }
    } else if (shapeName === 'star'){
      ctx.beginPath();
      const spikes = 7;
      for (let i=0;i<spikes*2;i++){
        const rad = i%2===0 ? r*1.05 : r*0.45;
        const ang = i/(spikes*2)*Math.PI*2 + (t*0.001);
        const x = Math.cos(ang) * rad;
        const y = Math.sin(ang) * rad;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    } else if (shapeName === 'roundedHex'){
      ctx.beginPath();
      const sides = 6;
      for (let i=0;i<sides;i++){
        const ang = i/sides*Math.PI*2 + t*0.0012;
        const x = Math.cos(ang) * r * (1 - 0.08*Math.sin(t*0.004 + i));
        const y = Math.sin(ang) * r * (1 - 0.08*Math.cos(t*0.003 + i));
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    } else if (shapeName === 'ringStack'){
      for (let i=0;i<3;i++){
        ctx.beginPath();
        const sc = 1 - i*0.22;
        ctx.arc(0,0, r * sc, 0, Math.PI*2);
        ctx.stroke();
      }
      // small center disc
      ctx.beginPath(); ctx.arc(0,0, r*0.22, 0, Math.PI*2); ctx.fill();
    } else if (shapeName === 'spiralBlob'){
      ctx.beginPath();
      for (let a=0;a<Math.PI*2; a+=0.08){
        const rr = r * (1 + 0.18*Math.sin(4*a + t*0.008));
        const x = Math.cos(a) * rr + 3*Math.sin(a*2 + t*0.01);
        const y = Math.sin(a) * rr + 3*Math.cos(a*3 + t*0.007);
        if (a===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    } else {
      // fallback circle
      ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill(); ctx.stroke();
    }
    ctx.restore();
  }

  // enemies: pulsing blobs drawing
  function drawBlob(e){
    // pulsing radius
    const pulse = 1 + 0.22 * Math.sin(t*0.01 + e.pulseSeed*3.2);
    const px = e.x, py = e.y;
    // layered translucent blobs for fluid look
    for (let k=2;k>=0;k--){
      const rr = e.baseR * pulse * (1 + 0.12*k);
      const alpha = 0.28 - k*0.06;
      ctx.beginPath();
      const wob = 0.8 * Math.sin(t*0.006 + e.wobbleSeed + k);
      for (let a=0; a<Math.PI*2; a+=0.26){
        const rvar = rr * (1 + 0.12*Math.sin(a*3 + t*0.01 + e.wobbleSeed + k));
        const x = px + Math.cos(a) * rvar + 1.2*Math.sin(a*1.7 + t*0.009 + e.wobbleSeed);
        const y = py + Math.sin(a) * rvar + 1.2*Math.cos(a*1.9 + t*0.008 + e.wobbleSeed);
        if (a===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.closePath();
      ctx.fillStyle = `hsla(${e.hue} 85% 60% / ${alpha})`;
      ctx.fill();
    }
    // core
    ctx.beginPath();
    ctx.arc(px,py, e.baseR * 0.54 * pulse, 0, Math.PI*2);
    ctx.fillStyle = `hsla(${e.hue} 85% 48% / 1)`;
    ctx.fill();
  }

  // update enemies fluidly, keep them on screen
  function updateEnemies(dt){
    for (let e of enemies){
      // gentle wander + attraction to player
      const dx = player.x - e.x, dy = player.y - e.y;
      const dist = Math.hypot(dx,dy) + 0.0001;
      const attract = Math.min(0.9, 40/dist);
      // wobble
      e.vx += (Math.cos(t*0.002 + e.wobbleSeed)*0.02 + (dx/dist)*0.08*attract) * e.speed;
      e.vy += (Math.sin(t*0.002 + e.wobbleSeed)*0.02 + (dy/dist)*0.08*attract) * e.speed;
      // damping
      e.vx *= 0.94; e.vy *= 0.94;
      e.x += e.vx * dt * 60;
      e.y += e.vy * dt * 60;
      // wrap so they never disappear — wallpaper is continuous
      if (e.x < -100) e.x = innerWidth + 100;
      if (e.x > innerWidth + 100) e.x = -100;
      if (e.y < -100) e.y = innerHeight + 100;
      if (e.y > innerHeight + 100) e.y = -100;
    }
  }

  // collision detection
  function handleCollisions(){
    for (let e of enemies){
      const dx = e.x - player.x, dy = e.y - player.y;
      const dist = Math.hypot(dx,dy);
      const threshold = e.baseR * 0.9 + player.r * 0.9;
      if (dist < threshold){
        if (player.inv <= 0){
          // damage
          player.health = Math.max(0, player.health - 12);
          player.flash = 18;
          player.inv = 36; // frames invincible
          // lightning flash: set overlay alpha via a variable
          lightning = 18;
          // nudge enemy away a bit
          const nx = dx / (dist+0.01), ny = dy / (dist+0.01);
          e.x += nx * 18; e.y += ny * 18;
        }
      }
    }
  }

  // move player smoothly toward target and scroll wallpaper
  function updatePlayer(dt){
    if (player.target){
      const dx = player.target.x - player.x, dy = player.target.y - player.y;
      const dist = Math.hypot(dx,dy);
      if (dist < 6) { player.target = null; player.vx = player.vy = 0; }
      else {
        const speed = 160; // px/s
        player.vx = (dx / dist) * speed;
        player.vy = (dy / dist) * speed;
        player.x += player.vx * dt;
        player.y += player.vy * dt;
        // wallpaper scroll as if player moves over huge wall
        world.x -= player.vx * dt * 0.6;
        world.y -= player.vy * dt * 0.6;
        // depth slowly increases with world travel
        depth = Math.min(12, Math.abs(world.x*0.0006) + Math.abs(world.y*0.0006));
      }
    } else {
      // small idle wobble
      player.x += Math.sin(t*0.003)*0.2;
      player.y += Math.cos(t*0.002)*0.15;
    }
    if (player.inv > 0) player.inv--;
    if (player.flash > 0) player.flash--;
    healthBarEl.style.width = player.health + '%';
  }

  // lightning overlay timer
  let lightning = 0;

  // touch controls
  const ongoing = {};
  canvas.addEventListener('touchstart', (ev) => {
    ev.preventDefault();
    const touches = ev.changedTouches;
    for (let tch of touches) ongoing[tch.identifier] = {x: tch.clientX, y: tch.clientY};
    // single tap -> set target
    if (Object.keys(ongoing).length === 1){
      const first = touches[0];
      player.target = { x: first.clientX, y: first.clientY };
    }
    // two-finger tap -> morph to next shape/color
    if (Object.keys(ongoing).length >= 2){
      // pick next shape/color
      player.shapeIndex = (player.shapeIndex + 1) % player.shapes.length;
      const hueChoices = [200, 260, 30, 140, 320, 50];
      player.color.h = hueChoices[Math.floor(Math.random()*hueChoices.length)];
      player.color.s = 70 + Math.floor(Math.random()*20);
      player.color.l = 48 + Math.floor(Math.random()*12);
    }
  }, { passive:false });

  canvas.addEventListener('touchmove', (ev) => {
    ev.preventDefault();
    // allow dragging target with one finger
    const touches = ev.changedTouches;
    for (let tch of touches){
      if (ongoing[tch.identifier]) ongoing[tch.identifier].x = tch.clientX, ongoing[tch.identifier].y = tch.clientY;
    }
    if (Object.keys(ongoing).length === 1){
      const p = Object.values(ongoing)[0];
      player.target = { x: p.x, y: p.y };
    }
  }, { passive:false });

  canvas.addEventListener('touchend', (ev) => {
    ev.preventDefault();
    for (let t of ev.changedTouches) delete ongoing[t.identifier];
  }, { passive:false });

  // mouse fallbacks (desktop)
  let mouseDown = false;
  canvas.addEventListener('mousedown', (e) => { mouseDown = true; player.target = { x: e.clientX, y: e.clientY }; });
  canvas.addEventListener('mousemove', (e) => { if (mouseDown) player.target = { x: e.clientX, y: e.clientY }; });
  canvas.addEventListener('mouseup', (e) => { mouseDown = false; });

  // main loop
  let last = performance.now();
  function frame(now){
    const dt = Math.min(0.06, (now - last) / 1000);
    last = now;
    t += dt * 1000;

    // update
    updatePlayer(dt);
    updateEnemies(dt);
    handleCollisions();

    // draw
    // bright background base
    ctx.fillStyle = '#07101a';
    ctx.fillRect(0,0,innerWidth, innerHeight);

    // wallpaper (bright lines)
    drawWallpaper();

    // draw enemies behind player but visible
    for (let e of enemies) drawBlob(e);

    // player stands out strongly
    const shapeName = player.shapes[player.shapeIndex];
    drawPlayerShape(player.x, player.y, player.r, shapeName, player.color, player.flash > 0 ? 1 : 0);

    // HUD: health handled by DOM

    // lightning flash overlay
    if (lightning > 0){
      ctx.fillStyle = `rgba(255,255,255,${0.18 * (lightning/18)})`;
      ctx.fillRect(0,0,innerWidth, innerHeight);
      lightning--;
    }

    // damage tint (brief red)
    if (player.flash > 0){
      ctx.fillStyle = `rgba(220,30,30,${0.12 * (player.flash/18)})`;
      ctx.fillRect(0,0,innerWidth, innerHeight);
    }

    // status text subtle (already in DOM)
    if (player.health <= 0){
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(0, innerHeight/2 - 44, innerWidth, 88);
      ctx.fillStyle = '#fff';
      ctx.font = '20px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('You were overwhelmed — Tap to respawn', innerWidth/2, innerHeight/2 + 6);
    }

    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // respawn on tap if dead
  canvas.addEventListener('touchstart', (e) => {
    if (player.health <= 0){
      player.health = 100;
      player.x = innerWidth/2 + (Math.random()-0.5)*100;
      player.y = innerHeight/2 + (Math.random()-0.5)*100;
      world.x = world.y = 0;
      for (let e of enemies){ e.x = Math.random()*innerWidth; e.y = Math.random()*innerHeight; }
    }
  }, { passive:false });

})();
</script>
</body>
</html>
	
